// Access Control and Protection Utilities
import { authService } from '../services/firebase';

// Environment-based access control
export const ACCESS_LEVELS = {
  PUBLIC: 'public',
  BETA: 'beta',
  PRIVATE: 'private',
  ADMIN: 'admin'
};

// Feature flags for gradual rollout
export const FEATURE_FLAGS = {
  EQUIPMENT_PLANNING: true,
  BUSINESS_CARD_OCR: true,
  URL_IMPORT: true,
  BUDGET_TRACKER: true,
  VENDOR_MANAGEMENT: true,
  COMPLIANCE_TRACKING: true
};

// Beta tester whitelist
const BETA_TESTERS = [
  'matt@iterumfoods.com',
  'test@example.com',
  // Add more beta tester emails here
];

// Admin users
const ADMIN_USERS = [
  'matt@iterumfoods.com'
];

// Rate limiting configuration
const RATE_LIMITS = {
  EQUIPMENT_IMPORT: { max: 10, window: 3600000 }, // 10 per hour
  VENDOR_ADD: { max: 5, window: 3600000 }, // 5 per hour
  DOCUMENT_UPLOAD: { max: 20, window: 3600000 }, // 20 per hour
};

// Track user actions for rate limiting
const userActionCounts = new Map();

export class AccessController {
  static async checkAccess(requiredLevel = ACCESS_LEVELS.PUBLIC) {
    try {
      const user = authService.getCurrentUser();
      
      if (!user || user.isAnonymous) {
        return requiredLevel === ACCESS_LEVELS.PUBLIC;
      }

      const userEmail = user.email;
      
      switch (requiredLevel) {
        case ACCESS_LEVELS.ADMIN:
          return ADMIN_USERS.includes(userEmail);
        case ACCESS_LEVELS.PRIVATE:
          return BETA_TESTERS.includes(userEmail) || ADMIN_USERS.includes(userEmail);
        case ACCESS_LEVELS.BETA:
          return BETA_TESTERS.includes(userEmail) || ADMIN_USERS.includes(userEmail);
        case ACCESS_LEVELS.PUBLIC:
        default:
          return true;
      }
    } catch (error) {
      console.error('Access check failed:', error);
      return false;
    }
  }

  static async checkFeatureAccess(feature) {
    if (!FEATURE_FLAGS[feature]) {
      return false;
    }

    // Check if user has access to beta features
    const hasBetaAccess = await this.checkAccess(ACCESS_LEVELS.BETA);
    
    // Some features require beta access
    const betaOnlyFeatures = ['BUSINESS_CARD_OCR', 'URL_IMPORT'];
    if (betaOnlyFeatures.includes(feature)) {
      return hasBetaAccess;
    }

    return true;
  }

  static checkRateLimit(action, userId) {
    const limit = RATE_LIMITS[action];
    if (!limit) return true;

    const now = Date.now();
    const userKey = `${userId}_${action}`;
    const userActions = userActionCounts.get(userKey) || { count: 0, resetTime: now + limit.window };

    // Reset if window has passed
    if (now > userActions.resetTime) {
      userActions.count = 0;
      userActions.resetTime = now + limit.window;
    }

    if (userActions.count >= limit.max) {
      return false;
    }

    userActions.count++;
    userActionCounts.set(userKey, userActions);
    return true;
  }

  static async requireAccess(requiredLevel = ACCESS_LEVELS.PUBLIC) {
    const hasAccess = await this.checkAccess(requiredLevel);
    if (!hasAccess) {
      throw new Error('Access denied. This feature requires higher permissions.');
    }
    return true;
  }

  static async requireFeature(feature) {
    const hasFeature = await this.checkFeatureAccess(feature);
    if (!hasFeature) {
      throw new Error('This feature is not available in your current access level.');
    }
    return true;
  }

  static async requireRateLimit(action, userId) {
    const withinLimit = this.checkRateLimit(action, userId);
    if (!withinLimit) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }
    return true;
  }
}

// Watermarking and tracking
export const addWatermark = (content, userId) => {
  const timestamp = new Date().toISOString();
  const watermark = `<!-- Generated by Restaurant Startup App - User: ${userId} - ${timestamp} -->`;
  return watermark + content;
};

// Data obfuscation for sensitive information
export const obfuscateData = (data, fields = ['email', 'phone', 'address']) => {
  const obfuscated = { ...data };
  fields.forEach(field => {
    if (obfuscated[field]) {
      obfuscated[field] = obfuscated[field].replace(/(.{2}).*(.{2})/, '$1***$2');
    }
  });
  return obfuscated;
};

// Session management
export class SessionManager {
  static startSession(userId) {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const sessionData = {
      userId,
      sessionId,
      startTime: Date.now(),
      actions: [],
      ipAddress: 'unknown' // Would be set by server
    };
    
    sessionStorage.setItem('currentSession', JSON.stringify(sessionData));
    return sessionId;
  }

  static logAction(action, details = {}) {
    const session = JSON.parse(sessionStorage.getItem('currentSession') || '{}');
    if (session.sessionId) {
      session.actions.push({
        action,
        details,
        timestamp: Date.now()
      });
      sessionStorage.setItem('currentSession', JSON.stringify(session));
    }
  }

  static endSession() {
    const session = JSON.parse(sessionStorage.getItem('currentSession') || '{}');
    if (session.sessionId) {
      // Send session data to analytics/logging service
      console.log('Session ended:', session);
      sessionStorage.removeItem('currentSession');
    }
  }
}

// Usage analytics
export const trackUsage = (feature, action, metadata = {}) => {
  const user = authService.getCurrentUser();
  const usageData = {
    feature,
    action,
    userId: user?.uid || 'anonymous',
    timestamp: Date.now(),
    metadata
  };
  
  // In production, send to analytics service
  console.log('Usage tracked:', usageData);
  
  // Store locally for now
  const userId = analyticsService.getCurrentUser()?.uid || 'anonymous';
  const key = `usageAnalytics_${userId}`;
  const usage = JSON.parse(localStorage.getItem(key) || '[]');
  usage.push(usageData);
  localStorage.setItem(key, JSON.stringify(usage.slice(-1000))); // Keep last 1000 entries
};

export default AccessController;
